/* 
 * liker script for STM32F407VG
 * Flash size: 1024KB, Memory size: 192KB
 *
* Copyright (c) 2015, YANG HONGBO
* All rights reserved.
* 
* Redistribution and use in source and binary forms, with or without modification, 
* are permitted provided that the following conditions are met:
* 
* 1. Redistributions of source code must retain the above copyright notice, this 
* list of conditions and the following disclaimer.
* 
* 2. Redistributions in binary form must reproduce the above copyright notice, 
* this list of conditions and the following disclaimer in the documentation and/or 
* other materials provided with the distribution.
* 
* 3. Neither the name of the copyright holder nor the names of its contributors 
* may be used to endorse or promote products derived from this software without 
* specific prior written permission.
* 
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
* ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
* BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
* OF THE POSSIBILITY OF SUCH DAMAGE.
 */
TARGET(elf32-littlearm)

MEMORY {
    CCM(rw) :   ORIGIN = 0x10000000, LENGTH = 64K
    FLASH(rx) : ORIGIN = 0x08000000, LENGTH = 1024K
    RAM(xrw)  : ORIGIN = 0x20000000, LENGTH = 128K
}

REGION_ALIAS("REGION_VECTOR", FLASH);
REGION_ALIAS("REGION_TEXT", FLASH);
REGION_ALIAS("REGION_LOADDATA", FLASH);
REGION_ALIAS("REGION_DATA", RAM);
REGION_ALIAS("REGION_BSS", RAM);
REGION_ALIAS("REGION_HEAP_STACK", RAM);

ENTRY(Reset_Handler)

/* adjust if will use heap */
min_heap_size = 0x200;
min_stack_size = 0x400;

/* End of 128K RAM 
 * AAPCS defines stack is full-descending 
 * the SP / r13 should be decremented then push data upon
 */
_estack = 0x20020000;

SECTIONS {
    _start_flash = .;
    .isr_vector : {
        . = ALIGN(4);
        KEEP(*(.isr_vector))
        . = ALIGN(4);
    } > REGION_VECTOR

    .text : { 
        . = ALIGN(4);
        *(.text) 
        *(.text*) 
        *(.rodata)
        *(.rodata*)

        /* .glue_7 and .glue_7t are generated by compiler for ARM-THUMB interworking option
         * better to be relocated to RAM
         */
        *(.glue_7)
        *(.glue_7t)
        *(.eh_frame)

        KEEP(*(.init))
        KEEP(*(.fini))

        . = ALIGN(4);
        _etext = .;
        PROVIDE( etext = . );
        _exit = .;
    } > REGION_TEXT

    .ARM.extab : {
        *(.ARM.extab* .gnu.linkonce.armextab.*)
    } > REGION_TEXT

    .ARM : {
        __exidx_s = .;
        /* for C++ exception handling
         */
        *(.ARM.exidx*)
        _exidx_end = .;
    } > REGION_TEXT

    .ARM.attributes 0 : { 
        *(.ARM.attributes)
    } > REGION_TEXT

    /* required by libc ? */
    .preinit_array : {
        PROVIDE (__preinit_array_start = .); 
        KEEP (*(.preinit_array*))
        PROVIDE (__preinit_array_end = .); 
    } > REGION_TEXT

    .init_array : {
        PROVIDE (__init_array_start = .); 
        KEEP (*(.init_array*))
        PROVIDE (__init_array_end = .); 
    } > REGION_TEXT

    .fini_array : {
        PROVIDE (__fini_array_start = .); 
        KEEP (*(.fini_array*))
        PROVIDE (__fini_array_end = .); 
    } > REGION_TEXT

    /* start address for the initialization values of the .data section. 
    needed by startup code */
    _sidata = .;
    .data : AT (_sidata){
        . = ALIGN(4);
        /* start address for the .data section. needed by startup code */  
        _sdata = .;
        *(.data)
        *(.data*)
        /* end address for the .data section. needed by startup code */
        _edata = .;
    } > REGION_DATA

    _end_flash = .;
    PROVIDE(_FLASH_SIZE = _end_flash - _start_flash);
    /*ASSERT(_FLASH_SIZE <= LENGTH(FLASH), "code size exceeds flash size");*/

    .bss (NOLOAD) :{
        . = ALIGN(4);
        /* start address for the .bss section. needed by startup code */
        _sbss = .;
        __bss_start__ = .; /* needed by crt0.o */
        *(.bss)
        *(.bss*)
        *(COMMON)

        . = ALIGN(4);
        /* end address for the .bss section. needed by startup code */
        _ebss = .;
        __bss_end__ = .; /* needed by crt0.o */

    } > REGION_BSS

    /* for some linked library */
    __end__ = . ;
    _end = .; 
    PROVIDE (end = .);

    /* according to other documents, following section is only to check if the section is overflow */
    ._user_heap_stack :{ 
        . = ALIGN(4);
        . = . + min_heap_size;
        . = . + min_stack_size;
        . = ALIGN(4);
    } > REGION_HEAP_STACK

    HIDDEN(_end_memory = .);
    /*ASSERT(_end_memory <= _estack, "Heap / Stack checker exceeds memory boundary"); */

    /DISCARD/ : {
        libgcc.a ( * )
        libc.a ( * )
        libm.a ( * )
    }
}
